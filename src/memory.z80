; Fills a range in memory with a specified byte value.
; hl = destination address
; bc = byte count
; a = byte value
memset:
    inc c
    inc b
    jr .start
.repeat:
    ld [hl+], a
.start:
    dec c
    jr nz, .repeat
    dec b
    jr nz, .repeat
ret

; Copies count bytes from source to destination.
; de = destination address
; hl = source address
; bc = byte count
memcpy:
    inc c
    inc b
    jr .start
.repeat:
    ld a, [hl+]
    ld [de], a
    inc de
.start:
    dec c
    jr nz, .repeat
    dec b
    jr nz, .repeat
ret

;;; STRUCT TRAVERSAL HELPERS ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

; Macro for moving to a specific element
; No register use guarantee! (maybe except for A?)
; TODO: Optimize for large distances
JMACRO SeekSruct(src, dst, hi, lo)
    let offset = dst - src;
    let retstr = "";
    let op = (offset > 0) ? "inc " : "dec ";

    while(offset != 0){
        retstr += op + hi + lo + "\n";
    }

    return retstr;
ENDJMACRO

; Same as SeekStruct, except \1 is a SETable
JMACRO SeekStructAndSet(src, dst, hi, lo)
    src += (dst - src);
    SeekStruct(src, dst, hi, lo);
ENDJMACRO

; TODO: SeekStructAtHLWithLD(AndSet) 
; which is a terrible name for a macro that increments/
; decrements HL with a load before calling SeekStrut

;;; REGISTER/MEMORY LABEL DEFINITON HELPERS ;;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

JMACRO InitRegistry()
    storage.REGISTRY_IN_USE = true;
    storage.a_SET = false;
    storage.b_SET = false;
    storage.c_SET = false;
    storage.d_SET = false;
    storage.e_SET = false;
    storage.h_SET = false;
    storage.l_SET = false;
ENDJMACRO

JMACRO DestroyRegistry()
    delete storage.REGISTRY_IN_USE;
    delete storage.a_SET;
    delete storage.b_SET;
    delete storage.c_SET;
    delete storage.d_SET;
    delete storage.e_SET;
    delete storage.h_SET;
    delete storage.l_SET;
ENDJMACRO

; Defines names for a pair of registers
; \1 = Prefix name, all caps
; \2 = first register in pair
; \3 = second register in pair
; Defines names \1_HI, \1_LO, \1_REG, \1_REF
; Checks against variables \2_SET, \3_SET
JMACRO RegisterPair(prefix, hi, lo)
    if(!storage["REGISTRY_IN_USE"]) {
        console.error("Use of registry function without init.")
        debugger;
        return;
    }

    if (storage[hi+"_SET"]) {
        console.error(hi + "is already set!");
        debugger;
        return;
    }

    if (storage[lo+"_SET"]) {
        console.error(lo + "is already set!");
        debugger;
        return;
    }

    console.log(prefix + ": " + lo + hi);

    storage[hi+"_SET"] = true;
    storage[lo+"_SET"] = true;

    storage[prefix] = new Object();
    storage[prefix]["hi"] = hi;
    storage[prefix]["lo"] = lo;
    storage[prefix]["reg"] = hi + lo;
    storage[prefix]["ref"] = "[" + hi + lo + "]";
ENDJMACRO

; Marks a macro pair as invalid
; \1 = Prefix name, all caps
JMACRO InvalidatePair(prefix)
    let hi = storage[prefix]["hi"];
    let lo = storage[prefix]["lo"];

    delete storage.prefix;
    storage[hi+"_SET"] = false;
    storage[lo+"_SET"] = false;
ENDJMACRO

; Moves a pair to another set of registers, with contents
; \1 = old pair name
; \2 = new pair hi
; \3 = new pair lo
JMACRO MovePair(prefix, hi, lo)
    console.log(prefix + " -> " + hi + lo);
    if (storage[hi+"_SET"]){
        console.error(hi + " is already set!");
        debugger;
        return;
    }
    if (storage[lo+"_SET"]){
        console.error(hi + " is already set!");
        debugger;
        return;
    }

    let retstr = "";
    retstr += "ld " + hi + ", " + storage.prefix.hi + "\n";
    retstr += "ld " + lo + ", " + storage.prefix.lo + "\n";
    InvalidatePair(@prefix);
    RegisterPair(@prefix, @hi, @lo);
    return retstr;

ENDJMACRO

; Registers a single register
; \1 = label name
; \2 = register
JMACRO RegisterSingle(prefix, reg)
    if(!storage["REGISTRY_IN_USE"]) {
        console.error("Use of registry function without init.")
        debugger;
        return;
    }

    if(storage[reg + "_SET"]){
        console.error(reg + " is already set!");
        debugger;
        return;
    }

    storage[reg + "_SET"] = 1;

    storage[prefix] = new Object();
    storage[prefix]["reg"] = reg;
    storage[prefix]["ref"] = "[" + reg + "]";
ENDJMACRO

; Unregisters a single register
; \1 = label name
JMACRO InvalidateSingle(prefix)
    let reg = storage[prefix]["reg"];
    storage[reg + "_SET"] = false;
    delete storage[prefix];
ENDJMACRO