SECTION "OBJECTS",ROM0

ACCEL_X_LO EQU $20
MAX_X_HI EQU $01

; Create bitfield in a containing a list of active objects.
; This is clever because you can rr x; jr nc to skip easily.
; We're storing the result in HiRAM for easy access.
; Also includes number of active objects as it's own variable.
GenerateActiveObjectsBitfield:
	xor a
	ld b, a ; result
	ld c, a ; count

	ld d, a ; For incrementing HL
	ld e, _get(`charStruct', `sizeof')

	ld hl, charArray ; Initial pointer

REPT 7
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .notactive\@ ; Skip if not active
	inc b ; Mark as active
	inc c ; Increment counter
.notactive\@:
	sla b ; Move b to the left
ENDR

; And one last time excluding the shift
	ld a, [hl] ; Get attributes
	add hl, de ; Increment HL to next object
	rla ; Set carry to active flag
	jr nc, .done ; Skip if not active
	inc b
	inc c
.done:

	; Save result
	ld a, b
	ldh [ActiveObjectsBitfield], a
	ld a, c
	ldh [ActiveObjectsCount], a

ret

; HL = pointer to beginning of given object
; Returned HL will be at charAnimSpeed
TickObject_Animation:
	define(`CHAROFFSET', _get(`charStruct', `start'))
	RegisterPair(CHARSTRUCT, h, l)

	; Set HL to charAnim
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `anim'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	; Set animation pointer to DE
	RegisterPair(ANIMBASE, d, e)
	ld ANIMBASE_reg, animations_pointers_start
	ld a, CHARSTRUCT_ref ; A = animation #
	; Move HL (object struct) to BC
	MovePair(CHARSTRUCT, b, c)

	; HL = Animation frame *= 2
	RegisterPair(ANIMOFF, h, l)
	rla
	ld ANIMOFF_hi, 0
	ld ANIMOFF_lo, a
	; Animation pointer (=HL) to relevant animation
	add ANIMOFF_reg, ANIMBASE_reg
	InvalidatePair(ANIMBASE)

	; Set DE=[HL] (animation data)
	RegisterPair(ANIMDATA, d, e)
	ld a, [ANIMOFF_reg+]
	ld ANIMDATA_lo, a
	ld ANIMDATA_hi, [ANIMOFF_reg]

	; Restore HL to be object pointer (@ charAnim)
	InvalidatePair(ANIMOFF)
	MovePair(CHARSTRUCT, h, l)

	; Store # of frames in B
	RegisterSingle(FRAMEMAX, b)
	inc ANIMDATA_reg ; DE = # of frames
	ld a, ANIMDATA_ref
	dec a ; Make zero-indexed
	ld FRAMEMAX_reg, a

	; Store current frame into C
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `animFrame'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	RegisterSingle(FRAMECURR, c)
	ld a, CHARSTRUCT_ref
	ld FRAMECURR_reg, a

	; Get animation timer (range from AnimSpeed to 0)
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `animTimer'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	ld a, CHARSTRUCT_ref
	or a
	jr z, .noreturn ; Return if not time to animate
	SeekStruct(CHAROFFSET, _get(`charStruct', `anim'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	jr .return

.noreturn
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `anim'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	; Set hl to animation frame
	; Check if we need to loop the animation
	; (Check if current frame == number of frames)
	ld a, FRAMEMAX_reg
	sub a, FRAMECURR_reg
	InvalidateSingle(`FRAMEMAX')
	InvalidateSingle(`FRAMECURR')
	jr z, .needsLoop
	
	; Increment animation frame, FFW hl, return
	SeekStruct(CHAROFFSET, _get(`charStruct', `animFrame'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	inc CHARSTRUCT_ref ; @ charAnimFrame
	SeekStruct(_get(`charStruct', `animFrame'), _get(`charStruct', `anim'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	jr .return

.needsLoop
	; Check what action we need to do
	inc ANIMDATA_reg ; DE = Loop Action
	ld a, ANIMDATA_ref
	rla ; Carry = action type
	jr nc, .getFrame

	; Set animation to a
	srl a ; This is equal to [de] & %01111111
	ld CHARSTRUCT_ref, a 

	; Set frame to 0
	xor a
	jr .setFrame

.getFrame:
	; Adjust [de] to be frame #
	srl a

.setFrame:
	; Store animation frame into object RAM and return
	SeekStruct(CHAROFFSET, _get(`charStruct', `animFrame'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	ld CHARSTRUCT_ref, a
	SeekStruct(_get(`charStruct', `animFrame'), _get(`charStruct', `animSpeed'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	ret

.return
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `animSpeed'), CHARSTRUCT_hi, CHARSTRUCT_lo)
	InvalidatePair(`CHARSTRUCT') ; hl
	InvalidatePair(`ANIMDATA') ; de
ret

TickObject_Timer:
	define(`CHAROFFSET', _get(`charStruct', `animSpeed'))
	; Get animation speed and current timer value
	ld a, [hl]
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `animTimer'), h, l)
	ld b, [hl]
	; Check if speed == value
	sub a, b
	jr z, .resetTimer
	; Increment timer
	inc b
	ld [hl], b
	jr .done
.resetTimer:
	; Set timer = 0
	xor a
	ld [hl], a
.done:
	; Set HL to next object attributes and return
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `next'), h, l)
	ret

; Runs 1 frame of player physics
; HL = Player object pointer
; A, BC, DE are clobbered
TickObject_Physics:
	RegisterPair(CHAR, h, l)
	define(`CHAROFFSET', _get(`charStruct', `start'))
	push CHAR_reg

	; Get dX and dY
	RegisterPair(dX, d, e)
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `dx'), CHAR_hi, CHAR_lo)
	;ld dX_reg, CHAR_ref 
	ld dX_lo, CHAR_ref
	inc CHAR_reg
	ld dX_hi, CHAR_ref
	dec CHAR_reg
	
	RegisterSingle(dY, c)
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `dy'), CHAR_hi, CHAR_lo)
	ld dY_reg, CHAR_ref

.addX:
	; This is funky, because we're adding a 16-bit number to a 24-bit
	; number on an 8-bit processor. As such we're ignoring the macro varnames
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `x'), CHAR_hi, CHAR_lo)
	inc CHAR_reg
	; Load current 8.8 into new HL (hl is character offset pair)
	ld a, [CHAR_reg+]
	ld b, [CHAR_reg]
	push CHAR_reg
	ld h, a
	ld l, b
	; Do a 16 bit of de and hl, move hl to de
	xor a
	add hl, dX_reg
	ld d, h
	ld e, l
	; restore char offset, move new de to [hl], carry adjust
	pop hl
	ld [hl], e
	dec hl
	ld [hl], d
	dec hl
	adc [hl]

	InvalidatePair(`dX')

.addY:
	; Move object pointer (hl) to Y
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `y'), CHAR_hi, CHAR_lo)

	; Add dY to Y
	ld a, CHAR_ref
	add a, dY_reg
	ld CHAR_ref, a
	InvalidateSingle(`dY')

	; Rewind stack and exit
	pop CHAR_reg
	InvalidatePair(`CHAR')
	ret

TickObject_PlayerInput:
	define(`CHAROFFSET', _get(`charStruct', `start'))
	RegisterPair(`CHAR', h, l)
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `dx'), CHAR_hi, CHAR_lo)

; Move player left/right with keys
; We want to deaccelerate when:
;	- Player has let go of all buttons
;	- Player is trying to go opposite of DX
; We want to accelerate when:
;	- Player is not moving but is pressing a button
;	- Player is trying to go same as DX

	RegisterPair(`dX', d, e)
	ld dX_lo, CHAR_ref
	inc CHAR_reg
	ld dX_hi, CHAR_ref

	; Are we pressing any buttons?
	RegisterSingle(`STATE', b)
	ld STATE_reg, 0
	ldh a, [JoypadButtons]
	and a, PADF_RIGHT | PADF_LEFT
	jr z, .run_none ; No direction is pressed

	; Did we switch from hard left to hard right?
	ldh a, [JoypadButtons]
	and a, PADF_RIGHT | PADF_LEFT

	ld b, a
	ldh a, [LastButtons]
	and a, PADF_RIGHT | PADF_LEFT

	xor a, b
	cp a, PADF_RIGHT | PADF_LEFT
	jp z, .run_none ; yep!

.run_left_start:
	; pressing left?
	ldh a, [JoypadButtons]
	and a, PADF_RIGHT

	; set state
	ld STATE_reg, 1
	jp nz, .run_right
	ld STATE_reg, 2

	; negate de
	xor a
	sub e
	ld e,a
	ld a,0
	sbc d
	ld d,a

.run_right:
	ld a, d
	cp a, MAX_X_HI
	jp nc, .run_left

	ld a, e
	add a, ACCEL_X_LO
	ld e, a
	jp nc, .run_left

	inc d
	jp .run_left

.run_left
	; pressing left?
	ldh a, [JoypadButtons]
	and a, PADF_RIGHT
	jp nz, .run_done

	; negate de
	xor a
	sub e
	ld e,a
	ld a,0
	sbc d
	ld d,a

	jp .run_done

.run_none
	ld de, 0

.run_done
	; load de into [hl]
	ld CHAR_ref, dX_hi
	dec CHAR_reg
	ld CHAR_ref, dX_lo

	InvalidatePair('dX')

.run_setanim
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `anim'), CHAR_hi, CHAR_lo)
	ld a, STATE_reg
	push bc
	cp a, 0
	jp z, .run_setanim_stop

	ld b, ANIM_RUN
	call SetAnim
	pop bc
	jp .run_setdir

.run_setanim_stop
	ld b, ANIM_IDLE
	call SetAnim
	pop bc

.run_setdir
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `info'), CHAR_hi, CHAR_lo)
	ld a, STATE_reg
	cp a, 0
	jp z, .return

	; left?
	cp a, 1
	jp z, .run_setdir_left

.run_setdir_right
	ld a, [hl]
	or a, %01000000
	ld [hl], a
	jp .return

.run_setdir_left:
	ld a, [hl]
	and a, %10111111
	ld [hl], a

.return
	SeekStructAndSet(`CHAROFFSET', _get(`charStruct', `start'), CHAR_hi, CHAR_lo)
	InvalidatePair(`CHAR')
	InvalidateSingle(`STATE')
	ret

; HL = object offset
TickObject:
; Get attributes in compact form
	ld a, [hl]
	rla
	ret nc ; Return if not active

	; todo: put a jump table here depending on object type
	call TickObject_PlayerInput

.ObjActionDone:
	; Do physics stuff
	call TickObject_Physics
	; Do animaton stuff
	call TickObject_Animation ; (HL @ charAnimSpeed)
	; Update timer
	call TickObject_Timer ; (HL @ next object)
ret

; Call TickObject for all objects
TickAllObjects:
	ld hl, charArray
	; We're going to need to keep bc on the stack...
	ldh a, [ActiveObjectsCount]
	ld b, a
	ldh a, [ActiveObjectsBitfield]
	ld c, a
.loop:
	rl c
	jr nc, .checkdone
	dec b

	push bc
	call TickObject
	pop bc

.checkdone
	ld a, b
	or a
	ret z
	jr .loop

; Just the definition for a sample object
SampleObject:
	DB %11000000 ; charInfo (active, left, player)
	DB FieldHeight, $00 ; Y
	DB $00, $80, $00 ; X
	DB 0 ; Animation
	DB 0 ; Frame
	DB 5 ; Animation Speed
	DB 0 ; Animation Timer
	DB 0, 0 ; Dx
	DB 0, 0 ; Dy
